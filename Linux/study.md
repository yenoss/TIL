### kernel이란? 

- 실제 하드웨어 를 컨트롤하지 않고 kernel이 관리해준다. 응용프로그램에서는 systemcall을 통해 리눅스 하드웨어 조작등을 할 수 있도록 설계되어 있다.

source구조

- kernel : 커널의 움직임을 제어
- mm: 메모리관리 (물리, 가상)
- fs: 가상 파일시스템 서브디렉토리
- net: 각종 네트워크 프로토콜에 관한 코드 tcp/ip unix domain socket..등 종속한 코드가 들어있음
- ipc: system v ipc(공유메모리, 세마포어,메시지)
- crypto: 암호처리
- block: block device컨트롤
- sound: soun 드라이버
- arch: cpu 아키텍쳐마다 동작해야되는 것들이 름 으로
- include: 각종 파일


### 커널 프로그래밍

- process scheduler
    - 기본 멀티태스크 환경제공, 복수의 프로세스가 병렬로 실행, 실제 cpu수보다 많은 것이 동시에 실행되지 않고 제어권한을 짧게 주면서 time 기반으로 배포해서 줌
    - 이러한 프로세스를 관리하는 것 프로세스 스케줄러라고 부름.
- interupt와 지연
    - 하드웨어는 interrupt형태로 처리하고 리눅스커널이 이를 받아서 수행
    - 리눅스 커널은 실행중인 처리를 중단하고 인터럽트를 수행
    - 인터럽트는 시스템 자체의 응답성과 부하를 줄 수 있음으로 소프트웨어 인터럽트라 불리는 처리를 지연시키는 구조가 구현되어있음.
- timer
    - 리눅스는 타이머를 가짐. 하드웨어로부터 일정주기마다 인터럽트를 잡아 타이머를 동작
    - 타이머처리는 시간을 계산하고 지정된처리를 수행할수 있도록 함
    - 네트웤 프로토콜 스택, 디바이스 드라이버에서 유용
- systemcall
    - 응용프로그램이 유일하게 커널에게 처리를 요청할 수 있는 방법
    - 시스템콜 발생 ⇒ 응용프로그램의 일시중지 ⇒ 커널 코드 실행
    - 리눅스 커널은 cpu가 제공하는 보호기능을 이용하여 리눅스 커널에 위치한 메모리 영역을 사용자 프로세스가 직접 액세스 할 수 없게함 ⇒ 함부로 고치거나하면 문제가 됨으로
- synchronization
    - 리눅스 커널은 동기화와 독점적 접근을 허용하기위해 다양한 방법을 사용, 여러 프로세스의 공유자원을  세마포어로 컨트롤 하거나  멀티 cpu가 동시에 참조하는 데이터를 보호하는 스핀락을 이용
    - 리눅스 커널에서 cpu간 자원 잠금 처리를 호율적으로 처리하는 Read copy update, sequence qcontuer lock을 도입하고 있음


### 프로세스 관리

- 프로그램의 실행 상태를 관리하는것을 말함. 실행하는 환경을 구축하고, 꺠긋하게 정리
- 리눅스 커널은 프로세스마다 관리하기위한 데이터 구조를 준비하고있음. 각 데이터 구조는 프로세스 ID, 우선순위, 공간정보, 이용중인 파일에 관전 정보 등 관리.

- process
    - 리눅스 프로세스는 fork 시스템 콜을 호출한 프로세스의 자식 프로세스를 생성하는것을 말함
    - 부모의 속성을 그대로 물려받은 자손을 만드는 것. 복제 정보는 프로세스 공간, 파일 오픈 상태, 디렉토리 정보, 시그널 동작 설정 등
    - 복제가 완료되면 자식 프로세스를 프로세스 스케쥴링 대상으로 추가
- signal
    - 프로세스에 비동기 이벤트를 전달하기 위한 장치
    - 시그널은 리눅스 커널의 다양한 곳에서 발생, 시그널을 받은 프로세스는 설정에 따라 디폴트, 동작, 무시, 시그널 핸들러 실행 등을 할 수 있음.
- thread
    - 리눅스 커널의 스레드는 일종의 프로세스로 구현, 프로세스와 다른 점은 스레드간 프로세스 공간을 공유하고 있고 스레드 관련 정보를 관리
    - 프로세서 스케쥴러에서 이 둘은 같은 존재
- memory management
    - 물리메모리: ram칩 안에 메모리 영역
        - 물리 메모리를 페이지 단위로 관리, 리눅스 커널은 페이지 단위로 물리메모리를 효율적으로 관리하기위해 버디 시스템이라는 방식을 사용
        - 버디 시스템은 서로 이웃한 영역을 결합해 큰 빈 영역을 만드는 방식
        - 리눅스 커널은 작은 메모리의 접근이 잦음. 이런 작은 메모리 영역을 효율적으로 관리하기위해 슬랙 할당자(slab allocator)로 불리는 메모리관리 방식을 가짐.
        - 단편화(fragment)의 발생을 줄이기 위한것 메모리 캐시 이용 효율을 고려한 메모리 방식
    - 가상메모리: 가상 메모리를 통해 물리메모리를 효율적으로 다룰 수 있음
        - 물리적으로 분산된 페이지를 모아 가상에서 할당 할 수 있다 ⇒ 단편화 문제를 해결
        - 리눅스 커널은 각 프로세스의 주소 공간을 독립적으로 할당 할 수 있음. 이를 다중 가상 공간이라 불름. 각 프로세스는 광대한 주소공간에 프로그램을 할당하고 실행
        - 하나의 프로세스는  다른프로세스와 경합하지 않고 자신만의 메모리를 사용. 텍스트,데이터,힙,스택 등을 할당할 수 있음.  ⇒ 메모리를 위한 공간을 여러개 가지고 있다라고 생각하면 됨
    - demending paging
        - 리눅스 커널은 페이징을 제공하지만 프로세스 공간 전부에 물리 메모리를 할당하지는 않음
        - 참조가 발생한 영역에 대해 페이지 단위로 물리 메모리를 할당 ⇒ 요구 페이징
        - 참조 빈도가 낮은 영역 ⇒ swap에 의해 반환
        - cow: 실제 쓰기가 발생할때까지 부모프로세스와 자식 프로세스의 페이지를 공유 할 수 있게 함
            - fork는 빈번하게 발생하는데 cow 구조에 의해 fork시 수행되는 프로세스의 공간 복제 처리를 최적화 할 수 있음
    - page out, swap
        - 리눅스 커널에서 페이지를 (물리 장치에)저장시키는 것을 swap.
        - 과거 unix는 프로세스 이미지 전체를 저장시키는 swap out이 있었으나, 페이지 단위로 저장시키는 페이지 아웃이 존재


    ### 파일 시스템

    - 파일시스템은 기억장치상의 데이터를 파일로 일관성 있게 제공
    - 리눅스 커널에서 파일은 byte stream. 커널은 파일안의 데이터 형태를 인식하지 않으며 해당 파일을 이용하는 각 프로그램에서 데이터 형태를 인식
    - 커널은 각 파일에 i node로 불리는 데이터 구조를 할당하여 관리 각 i node는 파일의 속성이나 파일 실제 데이터가 있는 2차 기억 장치 블록번호 등을 관리

    - file descripter
        - 파일 액세스는 open시스템콜을 실행하면서 파일 디스크립터라는 고유 번호가 반환
        - 이 후부터는 파일 디스크립터를 이용
        - 파일 디스크립터는 오픈상태가 fork에 의해 자식 프로세스로 계승됨으로 자식 프로세스는 파일을 열지도 않고 파일 디스크립터에 파일 입출력을 요청할 수 있음.
    - 캐시
        - 한번 읽은 데이터는 당분간 메모리상에 보존됨으로 두번째 부터는 파일 접근이 빨라짐. 또한 순차적으로 접근할 경우 read ahead를 수행해 데이터 접근이 빨라짐
        - i node와 파일 이름에대한 캐시도 준비되어있음. 자주 사용되는 파일의 i node를 복사해 캐싱함
    - 가상 파일 시스템
        - vfs라 불리는 가상 시스템은 다양한 종료의 파일 시스템을 배치할 수 있음
        - 이용자는 하위 파일 시스템이 어떤 것인지 알 필요없이 동일한 인터페이스롤 접근할 수 있게됨
    - local file system
        - 2차 기억장치를 사용하기 위한 파일 시스템
        - ex2뿐만 아니라 다른 os의 파일 시스템으로 이용 가능
    - network file system
        - 네트워크 파일시스템은 네트워크 끝에 있는 원격 머신이 갖는 파일시스템을 호스트의 로컬파일 시스템처럼 이용 ⇒ nfs ISCSI같은 것 들
    - 유사 파일
        - 진짜인 것처럼 가장한 파일 시스템 proc 같은..
        - proc은 리눅스 커널 내의 데이터 구조를 파일로 보이게 하기 위한 인터페이스
        - 이 파일을 읽고 쓰는 것은 리눅스 커널 정보를 얻거나 리눅스 커널 설정을 동적으로 변경할 수 있음
    - 리눅스 표준 파일 시스템 ext2
        - 전통적이고 ext파일 시스템의 결점을 확장한것
        - bsd의 ffs 설계를 참고하여 넣은 듯한 구조로 설계됨
        - 블록 그룹: 1개의 파일시스템에 놓여질 2차 기억장치를 몇 개의 영역으로 구분한 후 관련 데이터를 가능한 같은 영역에 확보함 으로 파일 접근을 최적화 하는 것
    - ext3
        - ext2에서 journaling이 추가됨 fault tolerance를 높이는 것이 특징으로. 이상종료후 파일시스템 복구 최적화를 위해 도입
    - block device
        - 파일 시스템의 요청에 따라 실제 입출력 장치를 수행하는 것
        - 이전버전에서는 버퍼단위로 IO를 했지만 지금은 더욱 큰 단위로(여러페이지)를 한 단위로 처리 할 수 있도록 함
        - 또한, 리눅스 블록디바이스 드라이버에서 엘레베이터 구조를 사용하고 있는데 입출력 순서를 정렬한후 오랜시간 대기한 것들에 대해 일정 시간 이상 지연되지 않도록 제어


### Network

- 과거 unix는 프로세스간 통신만 제공하고있었고 유연성이 풍부한 통신을 우해 소켓이 등장

- 소켓
    - 소켓은 임의의 프로세스끼리 통신할 수 있게 함
    - 하위층에 다양한 통신 프로토콜을 정의 할수 있고 호스트와 프로세스간 통신도 가능
    - 소켓 인터페이스는 커널 내에 구현되어있음
    - 소켓 송수신 데이터는 소켓 버퍼 구조로 관리
    - 데이터 교환을 단순하게 구현하려면 데이터복사가 여럿 발생할 수 있음으로 소켓 버퍼는 데이터 복사가 발생하지 않도록 구현되어 있음
    - 이를 위해 소켓 데이터 부분을 공유하는 구조라든가 해더를 붙이는 구조등을 사용
- TCP IP
    - 리눅스 커널은  tcp ip표준 외 패킷 필터링, NAT 기능, 부하공유 등을 가지고 있고 리눅스 탑재 머신을 방화벽이나 로드밸런서로도 사용
    - 시스템콜 ⇒ vfs ⇒ 소켓 ⇒ inet ⇒ ip / udp / tcp ⇒ dl이더넷 드라이버 등으로 연결되어 있음


### 프로세스간 통신

- 기본적으로 프로세스는 독립적으로 동작하지만 복수 프로세스가 제휴되어 동작할 수 있음
- 파이프는 부모와 자식 프로세스에 연결되어있고 이 파이브로 단순한 커맨드를 조합해 복잡한 동작 구현가능
- 리눅스에서는 쓸데없는 프로세스 변환 컨트롤을 위해 선점 횟수를 제어하도록 되어있음
- system v ipc로 불리는 통신도 있음 공유메모리 세마포어 메시지 등이 이것임


### 리눅스 커널 부팅 과정

- 전원 ⇒ LLIO,GRUB등 부트로더가 실행
- 커널의 이미지가 메모리상에 읽혀지면 리눅스 커널이 실행
- 멀티프로세서 머신도 부팅처리만은 1개의 cpu가 처리
- 가장 먼저 메모리상에 있는 커널 기본 기능의 데이터 구조를 초기화
- 다음 프로세스 Id 1번인 프로세스를 기동 초기화 처리, 1번프로세스가 수행하는 초기화 처리는 대가기 필요한 각종 디바이스를 초기화하거나 루트디바이스를 마운트하는 것, 가곶ㅇ 커널 스레드 부팅도 초기화처리내에서 수행
- 마지막으로 이 프로세스는 init프로그램을 exec로 실행하고 init이 실행됨


### 커널 동작 예제

- fread를 호출해 파일 데이터를 수행할경우
    - syscall  fread 호출
    - read 시스템콜을 발행, read는 x86에서는 init0x80 또는 sysenter 명령을 실행하고 강제적으로 인터럽트를 발생
    - 리눅스 커널은 read 시스템콜을 처리 가상 파일 시스템기능임으로 가상 파일시스템에서 대상 파일에 맞는 파일 시스템에 일긱요청(ex2..)
    - ex2는 대상이되는 파일 데이터가 어느 디바이스의 어느 블록에 배치되있는지 알아서 디바이스를 제어할 블록 디바이스 드라이버에 읽기를 요청
    - 블록 디바이스 드라이버는 하드웨어를 제어하여 리눅스 커널내의 캐시 영역으로 전송, 전송이 완료되면 하드웨어 인터럽트 형태로 리눅스에게 알림
    - 인터럽트를 받으면 블록디바이스 드리이버의 인터럽트 처리가 실행, 드라이버는 인터럽트로부터 파일 시스템에 대상 블록에 데이터 읽기가 완료된것을 알림
    - 파일 시스템은 리눅스 커널내의 캐시영역으로부터 fread가 관리하는 버퍼내의 데이터를 복사(아까 리눅스 캐시에 올린것으로부터 실제 fread호출한 곳으로 데이터를 주는것)
    - 끝
